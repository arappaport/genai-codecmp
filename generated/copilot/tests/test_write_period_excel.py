# GENERATED FILE - DO NOT EDIT DIRECTLY.
# Prompt: write_period_excel_prompt.txt  Version: 1.1
# Generated by: Copilot v1.0
# Timestamp: 2025-08-16T16:01:00Z

import os
import pandas as pd
import pytest
from pandas.testing import assert_frame_equal
from write_period_excel import write_period_excel


def make_sample_data():
    df_readme = pd.DataFrame({
        "note": ["Report generated for review"],
        "date": [pd.Timestamp("2025-08-16")],
    })
    df = pd.DataFrame({
        "app": ["A", "A", "B", "B", "C"],
        "user": ["u1", "u2", "u1", "u3", "u2"],
        "count": [1, 2, 3, 4, 5],
    })
    return df_readme, df


def test_write_period_excel_success(tmp_path):
    df_readme, df = make_sample_data()
    out_path = tmp_path / "summary.xlsx"
    write_period_excel(df_readme, df, str(out_path))

    # Read back and validate sheets
    with pd.ExcelFile(out_path) as xl:
        readme = xl.parse("README")
        users = xl.parse("users")
        apps = xl.parse("apps")
        data = xl.parse("data")

    # README sheet matches original
    assert_frame_equal(readme, df_readme, check_dtype=False)

    # Expected per-user summary
    expected_users = pd.DataFrame({
        "user": ["u1", "u2", "u3"],
        "apps": [2, 2, 1],
        "reqs": [4, 7, 4],
    })
    assert_frame_equal(users, expected_users, check_dtype=False)

    # Expected per-app summary
    expected_apps = pd.DataFrame({
        "app": ["B", "A", "C"],
        "users": [2, 2, 1],
        "reqs": [7, 3, 5],
    })
    assert_frame_equal(apps, expected_apps, check_dtype=False)

    # Data sheet matches original
    assert_frame_equal(data, df, check_dtype=False)


@pytest.mark.parametrize("bad_df_readme", [None, "not_df", 123])
def test_invalid_df_readme_type(bad_df_readme):
    df_readme = bad_df_readme
    df = pd.DataFrame({"app": [], "user": [], "count": []})
    with pytest.raises(TypeError):
        write_period_excel(df_readme, df, "out.xlsx")


@pytest.mark.parametrize("bad_df", [None, "not_df", 123])
def test_invalid_df_type(bad_df):
    df_readme = pd.DataFrame({"x": [1]})
    df = bad_df
    with pytest.raises(TypeError):
        write_period_excel(df_readme, df, "out.xlsx")


@pytest.mark.parametrize("bad_path", [None, 123, b"bytes"])
def test_invalid_path_type(bad_path):
    df_readme = pd.DataFrame({"x": [1]})
    df = pd.DataFrame({"app": [], "user": [], "count": []})
    with pytest.raises(TypeError):
        write_period_excel(df_readme, df, bad_path)


def test_empty_df_readme():
    df_readme = pd.DataFrame(columns=["foo"])
    df = pd.DataFrame({"app": [], "user": [], "count": []})
    with pytest.raises(ValueError):
        write_period_excel(df_readme, df, "out.xlsx")


def test_missing_columns_in_df():
    df_readme = pd.DataFrame({"x": [1]})
    df = pd.DataFrame({"app": [1], "user": [2]})
    with pytest.raises(ValueError) as excinfo:
        write_period_excel(df_readme, df, "out.xlsx")
    assert "missing required columns" in str(excinfo.value)


def test_write_permission_error(tmp_path, monkeypatch):
    df_readme, df = make_sample_data()
    # Simulate unwritable path by pointing to non-existent directory
    bad_dir = tmp_path / "no_dir" / "sub"
    out_file = bad_dir / "file.xlsx"
    with pytest.raises(Exception) as excinfo:
        write_period_excel(df_readme, df, str(out_file))
    assert "Failed to write Excel file" in str(excinfo.value)