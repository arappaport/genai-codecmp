# GENERATED FILE - DO NOT EDIT DIRECTLY.
# Prompt: calc_usage_metrics.txt  Version: 1.1
# Generated by: Microsoft Copilot (GPT-4)
# Timestamp: 2025-08-17T23:38:00Z

from typing import Any
import pandas as pd


def calc_usage_metrics(df: pd.DataFrame) -> pd.DataFrame:
    """Calculate user activity metrics from a usage DataFrame.

    Args:
        df (pd.DataFrame): Input DataFrame containing 'User Principal Name', 'Display Name', and 'Last Activity Date'.

    Returns:
        pd.DataFrame: Aggregated usage metrics per user.

    Raises:
        TypeError: If input is not a pandas DataFrame.
        ValueError: If DataFrame is empty or missing required columns.
    """
    if not isinstance(df, pd.DataFrame):
        raise TypeError("Input must be a pandas DataFrame.")

    required_columns = {'User Principal Name', 'Display Name', 'Last Activity Date'}
    if df.empty:
        raise ValueError("Input DataFrame must not be empty.")
    if not required_columns.issubset(df.columns):
        raise ValueError(f"Missing required columns: {required_columns - set(df.columns)}")

    df = df.copy()

    # Normalize 'Last Activity Date'
    def normalize_date(val: Any) -> str:
        if pd.isna(val) or str(val).strip().lower() == 'resigned' or str(val).strip() == '':
            return 'never'
        try:
            date_str = pd.to_datetime(val).strftime('%Y-%m-%d')  # trim down to YYYY-MM-DD
            return date_str[:10]
        except Exception:
            return 'never'

    df['Last Activity Date'] = df['Last Activity Date'].apply(normalize_date)

    # Aggregate min/max per user
    df_usage = df.groupby('User Principal Name', as_index=False)['Last Activity Date'].agg(['min', 'max']).reset_index()
    df_usage.rename(columns={'min': 'Minimum Activity Date', 'max': 'Maximum Activity Date'}, inplace=True)

    # ever_active: 1 if max date is not 'never'
    df_usage['ever_active'] = df_usage['Maximum Activity Date'].apply(lambda x: 1 if x != 'never' else 0)

    # active_days_range
    def compute_range(row: pd.Series) -> int:
        try:
            if row['Minimum Activity Date'] == 'never' or row['Maximum Activity Date'] == 'never':
                return 0
            min_date = pd.to_datetime(row['Minimum Activity Date'])
            max_date = pd.to_datetime(row['Maximum Activity Date'])
            return (max_date - min_date).days + 1
        except Exception:
            return 0

    df_usage['active_days_range'] = df_usage.apply(compute_range, axis=1)

    # max_usage_date
    valid_dates = df_usage[df_usage['Maximum Activity Date'] != 'never']['Maximum Activity Date']
    if valid_dates.empty:
        max_usage_date = pd.Timestamp('1970-01-01')
    else:
        max_usage_date = pd.to_datetime(valid_dates.max())

    # days_since_last_use
    def compute_days_since(val: str) -> int:
        try:
            if val == 'never':
                return 0
            return (max_usage_date - pd.to_datetime(val)).days
        except Exception:
            return 0

    df_usage['days_since_last_use'] = df_usage['Maximum Activity Date'].apply(compute_days_since)

    return df_usage