# GENERATED FILE - DO NOT EDIT DIRECTLY.
# Prompt: calc_usage_metrics.txt  Version: 1.1
# Generated by: Grok, created by xAI
# Timestamp: 2025-09-01T23:59:00Z

import pandas as pd
from pandas import DataFrame
from datetime import datetime
import numpy as np

def calc_usage_metrics(df: DataFrame) -> DataFrame:
    """Calculate usage metrics from a DataFrame based on user activity dates.

    Args:
        df (DataFrame): Input DataFrame containing 'User Principal Name', 'Display Name',
            and 'Last Activity Date' columns.

    Returns:
        DataFrame: Processed DataFrame with usage metrics including min/max activity dates,
            ever_active status, active days range, and days since last use.

    Raises:
        TypeError: If df is not a pandas DataFrame.
        ValueError: If df is empty or missing required columns.
    """
    # Input validation
    if not isinstance(df, DataFrame):
        raise TypeError("Input 'df' must be a pandas DataFrame")
    if df.empty:
        raise ValueError("Input DataFrame cannot be empty")
    required_columns = ['User Principal Name', 'Display Name', 'Last Activity Date']
    missing_columns = [col for col in required_columns if col not in df.columns]
    if missing_columns:
        raise ValueError(f"DataFrame missing required columns: {', '.join(missing_columns)}")

    # Create a copy of the DataFrame
    df_copy = df.copy()

    # Process 'Last Activity Date' column
    def format_date(value):
        if pd.isna(value) or str(value).strip().lower() == 'resigned':
            return 'never'
        try:
            # Convert to datetime and format to YYYY-MM-DD
            date = pd.to_datetime(value, errors='coerce')
            if pd.isna(date):
                return 'never'
            # Trim down to YYYY-MM-DD
            return date.strftime('%Y-%m-%d')
        except (ValueError, TypeError):
            return 'never'

    df_copy['Last Activity Date'] = df_copy['Last Activity Date'].apply(format_date)

    # Create df_usage with min and max of Last Activity Date per User Principal Name
    df_usage = df_copy.groupby('User Principal Name').agg({
        'Last Activity Date': ['min', 'max'],
        'Display Name': 'first'
    }).reset_index()

    # Flatten column names
    df_usage.columns = [
        'User Principal Name',
        'Minimum Activity Date',
        'Maximum Activity Date',
        'Display Name'
    ]

    # Create ever_active column
    df_usage['ever_active'] = df_usage['Maximum Activity Date'].apply(
        lambda x: 1 if x != 'never' else 0
    )

    # Calculate active_days_range
    def calculate_days_range(row):
        min_date = row['Minimum Activity Date']
        max_date = row['Maximum Activity Date']
        if min_date == 'never' or max_date == 'never':
            return 0
        try:
            min_dt = pd.to_datetime(min_date)
            max_dt = pd.to_datetime(max_date)
            return (max_dt - min_dt).days + 1
        except (ValueError, TypeError):
            return 0

    df_usage['active_days_range'] = df_usage.apply(calculate_days_range, axis=1)

    # Find max_usage_date
    valid_dates = df_usage[df_usage['Maximum Activity Date'] != 'never']['Maximum Activity Date']
    max_usage_date = pd.to_datetime(valid_dates).max() if not valid_dates.empty else None

    # Calculate days_since_last_use
    def calculate_days_since_last(row):
        if row['Maximum Activity Date'] == 'never' or max_usage_date is None:
            return 0
        try:
            max_dt = pd.to_datetime(row['Maximum Activity Date'])
            return (max_usage_date - max_dt).days
        except (ValueError, TypeError):
            return 0

    df_usage['days_since_last_use'] = df_usage.apply(calculate_days_since_last, axis=1)

    return df_usage