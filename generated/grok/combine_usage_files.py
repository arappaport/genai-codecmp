# GENERATED FILE - DO NOT EDIT DIRECTLY.
# Prompt: combine_usage_files_prompt.txt  Version: 1.0
# Generated by: Grok, created by xAI
# Timestamp: 2025-09-02T00:05:00Z

import os
import pandas as pd
from pandas import DataFrame
from pathlib import Path
import logging
from datetime import datetime

# Configure logging
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


def combine_usage_files(path: str | Path) -> DataFrame:
    """Combine all CSV and Excel files from a directory into a single DataFrame.

    Args:
        path (str | Path): Path to the directory containing CSV and Excel files.

    Returns:
        DataFrame: Combined DataFrame with an additional 'file' column indicating source file.

    Raises:
        TypeError: If path is not a string or Path object.
        ValueError: If path does not exist, is not a directory, or contains no valid files.
        RuntimeError: If file reading fails or date conversion encounters issues.
    """
    logger.debug("Starting combine_usage_files with path: %s", path)

    # Input validation
    if not isinstance(path, (str, Path)):
        logger.error("Invalid input type for path: %s", type(path))
        raise TypeError("Input 'path' must be a string or Path object")

    path = Path(path)
    logger.debug("Converted path to Path object: %s", path)

    if not path.exists():
        logger.error("Path does not exist: %s", path)
        raise ValueError(f"Path does not exist: {path}")

    if not path.is_dir():
        logger.error("Path is not a directory: %s", path)
        raise ValueError(f"Path is not a directory: {path}")

    # Initialize empty DataFrame
    df = pd.DataFrame()
    valid_extensions = {'.csv', '.xlsx', '.xls'}
    files_processed = 0

    # Iterate through files in directory
    for file_path in path.iterdir():
        if file_path.suffix.lower() in valid_extensions:
            logger.info("Processing file: %s", file_path)
            try:
                # Read file based on extension
                if file_path.suffix.lower() == '.csv':
                    df_tmp = pd.read_csv(file_path)
                else:
                    df_tmp = pd.read_excel(file_path)

                logger.debug("Successfully loaded file: %s with %d rows", file_path, len(df_tmp))

                # Add file name column
                df_tmp['file'] = file_path.name

                # Convert date columns to YYYY-MM-DD format
                for column in df_tmp.columns:
                    if pd.api.types.is_datetime64_any_dtype(df_tmp[column]) or \
                            df_tmp[column].astype(str).str.match(r'^\d{4}-\d{2}-\d{2}.*$').any():
                        logger.debug("Converting column %s to date format", column)
                        try:
                            df_tmp[column] = pd.to_datetime(
                                df_tmp[column], errors='coerce'
                            ).dt.strftime('%Y-%m-%d')
                        except Exception as e:
                            logger.error("Failed to convert dates in column %s: %s", column, str(e))
                            raise RuntimeError(f"Failed to convert dates in column {column}: {str(e)}")

                # Append to main DataFrame
                df = pd.concat([df, df_tmp], ignore_index=True)
                files_processed += 1
                logger.debug("Appended %s to main DataFrame. Current size: %d rows",
                             file_path.name, len(df))

            except Exception as e:
                logger.error("Error processing file %s: %s", file_path, str(e))
                raise RuntimeError(f"Error processing file {file_path}: {str(e)}")

    if files_processed == 0:
        logger.warning("No valid CSV or Excel files found in directory: %s", path)
        raise ValueError("No valid CSV or Excel files found in directory")

    logger.info("Completed processing. Total files: %d, Total rows: %d",
                files_processed, len(df))
    return df